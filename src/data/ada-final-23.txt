Q: Dada la siguiente relación de recurrencia, ¿Qué cota es verdadera?
$$f(n) = \begin{cases} 1 & n = 1 \\ n^2 + 2f(n/4) & n > 1 \end{cases}$$
O: $f(n) \in \Theta(n^2)$
O: $f(n) \in \Theta(n^2 \log n)$
O: $f(n) \in \Theta(n^3)$
A: 0
C: Julio 2023

Q: De las siguientes igualdades, o bien dos son ciertas y una es falsa, o bien una es cierta y dos son falsas. Marca la que es diferente a las otras dos.
O: $\Theta(n) = O(n) \cup \Omega(n)$
O: $\Theta(n) = O(n) \cap \Omega(n)$
O: $O(n) = O(n) \cap \Theta(n)$
A: 2
C: Julio 2023

Q: ¿Cuál es la condición base para terminar la recursión en la implementación por divide y vencerás del problema restringido del laberinto?
O: Llegar al inicio del laberinto (fila 0 columna 0) o al final del laberinto (fila $m - 1$, columna $n - 1$), según cómo se establezca la recursión.
O: Llegar a una celda con valor 0 en el laberinto.
O: Las otras dos opciones son ambas ciertas.
A: 2
C: Julio 2023

Q: En la implementación naive de la versión restringida del problema del laberinto, en el caso de que las tres direcciones sean posibles ¿qué hay que hacer con las longitudes de los caminos obtenidos con las llamadas recursivas?
O: Elegir la más grande y sumarle uno.
O: Elegir la más pequeña y sumarle uno.
O: Elegir la más cercana y sumarle uno.
A: 1
C: Julio 2023

Q: ¿Qué estructuras de datos utilizaste en la implementación naive de la versión restringida del problema del laberinto? (excluyendo el laberinto)
O: Una cola de prioridad.
O: Una matriz bidimensional.
O: Ninguna de las otras dos opciones es cierta.
A: 2
C: Julio 2023

Q: ¿En qué parte de los algoritmos que hacen uso de la memoización se realiza la verificación de si un subproblema ha sido ya resuelto?
O: Al inicio del algoritmo.
O: Antes de realizar la llamada recursiva.
O: Después de realizar la llamada recursiva.
A: 0
C: Julio 2023

Q: Queremos conocer el camino de mínima longitud en el problema restringido del laberinto usando un algoritmo de programación dinámica con la técnica de complejidad espacial mejorada (con dos vectores). ¿Cómo se puede obtener?
O: Ninguna de las otras dos opciones es válida.
O: Recorriendo el primer vector, empezando por la casilla de salida y buscando los resultados de los subproblemas accesibles a partir de ella.
O: Recorriendo el primer vector, empezando por la casilla de entrada y buscando los resultados de los subproblemas accesibles a partir de ella.
A: 0
C: Julio 2023

Q: ¿Qué estrategia es mejor en los algoritmos voraces para resolver el problema restringido del laberinto?
O: Elegir siempre la dirección hacia la salida más cercana que no esté bloqueada.
O: Elegir la dirección con menos obstáculos en cada paso.
O: Elegir aleatoriamente una dirección en cada paso.
A: 0
C: Julio 2023

Q: ¿Qué estrategia se sigue para realizar la exploración del laberinto con la técnica de vuelta atrás?
O: Realizar una búsqueda en profundidad siguiendo un orden predefinido de movimientos.
O: Utilizar una búsqueda en amplitud para explorar todas las posibles soluciones en paralelo.
O: Realizar una búsqueda heurística utilizando una función de evaluación para guiar la exploración hacia la solución óptima.
A: 0
C: Julio 2023

Q: En la aplicación al problema general del laberinto del algoritmo de ramificación y poda utilizando una cola de prioridad, ¿qué función cumple la cola de prioridad en el proceso de exploración del laberinto?
O: Ordenar los caminos explorados en función de un criterio de evaluación para seleccionar el siguiente camino a explorar.
O: Almacenar todos los caminos explorados para su posterior análisis y comparación.
O: Realizar una búsqueda en amplitud de todos los caminos posibles antes de tomar una decisión.
A: 0
C: Julio 2023

Q: Si estamos procesando la casilla $(i,j)$ y la casilla de salida del laberinto es la $(m,n)$, ¿cuál de las siguientes opciones será una buena cota pesimista al camino que queda por recorrer?
O: $\max(|m - i|, |n - j|)$
O: $|m - i| + |n - j|$
O: Ninguna de las otras dos opciones es cierta.
A: 2
C: Julio 2023

Q: Decid cuál de estas tres afirmaciones sobre el problema de la mochila sin división de los objetos y con pesos discretos es cierta.
O: El algoritmo de programación dinámica iterativa que lo resuelve calcula el mismo número de subproblemas que un algoritmo de programación dinámica recursiva (del tipo "divide y vencerás" que gestiona un almacén de memoización).
O: El algoritmo de programación dinámica iterativa que lo resuelve precisa como mucho un espacio del orden de $\Theta(n)$ donde $n$ es el número de objetos.
O: El algoritmo de programación dinámica iterativa que lo resuelve precisa como mucho un espacio del orden de $\Theta(P)$ donde $P$ es el peso máximo de la mochila.
A: 2
C: Julio 2023

Q: ¿Qué estructura de datos es la más eficiente en la programación dinámica iterativa para almacenar los subproblemas resueltos del problema de la mochila sin división de los objetos y con pesos discretos?
O: Una cola de prioridad.
O: Una matriz unidimensional.
O: Un árbol binario.
A: 1
C: Julio 2023

Q: Di cuál de estas tres afirmaciones sobre las soluciones basadas en algoritmos de búsqueda y enumeración (vuelta atrás, ramificación y poda) para el problema de la mochila sin división de los objetos es cierta.
O: No requieren que los pesos sean discretos o discretizables.
O: Requieren que los pesos sean discretos o discretizables para definir los niveles del árbol de búsqueda.
O: Deben visitar obligatoriamente todas las soluciones factibles para determinar cuál es la solución óptima.
A: 0
C: Julio 2023

Q: ¿Cuál de estos tres algoritmos de ordenación de vectores tiene una complejidad temporal en el caso peor que es cuadrática con la longitud del vector?
O: Quicksort
O: Mergesort
O: Heapsort
A: 0
C: Julio 2023

Q: ¿Cuál de estos tres algoritmos de ordenación de vectores tiene la peor complejidad temporal en el caso mejor?
O: Mergesort
O: Ordenación por inserción.
O: Quicksort.
A: 1
C: Julio 2023

Q: Indica cuál de estos tres algoritmos necesita espacio adicional para ordenar el vector.
O: Heapsort
O: Quicksort
O: Mergesort
A: 2
C: Julio 2023

Q: Indica para cuál de estos tres algoritmos de ordenación el coste temporal asintótico en el caso peor es peor que el coste temporal asintótico en el caso mejor.
O: Heapsort
O: Quicksort
O: Mergesort
A: 1
C: Julio 2023

Q: ¿Cuál es la complejidad temporal (en función de n) del fragmento siguiente de C++?
```cpp
for (int i = n; i > 0; i /= 2)
  for (int j = 0; j < n; j++)
    cout << '*';
```
O: $\Theta(n \log n)$
O: $\Theta(n^2)$
O: $\Theta(n)$
A: 0
C: Julio 2023

Q: El algoritmo de ordenación por selección y heapsort son similares en que obtienen el máximo de los n elementos, lo ponen al final, y después hacen lo mismo con n − 1 elementos, así hasta que sólo les queda un elemento. Di cuál de estas afirmaciones es cierta:
O: Por ello, la complejidad temporal asintótica en el caso peor de heapsort y del algoritmo de ordenación por inserción es la misma.
O: La complejidad temporal asintótica en el caso peor del algoritmo de ordenación por selección es peor porque, al contrario que heapsort, debe realizar necesariamente k operaciones para determinar cuál es el máximo de los primeros k elementos del vector.
O: La complejidad temporal asintótica en el caso mejor del algoritmo de ordenación por selección es mejor que la de heapsort porque la gestión la estructura de heap lo encarece.
A: 1
C: Julio 2023

Q: ¿Tiene sentido usar el método de ramificación y poda para encontrar la solución (o una solución) de un problema que no es de optimización?
O: No, porque al no ser un problema de optimización, no es posible usar cotas optimistas y pesimistas.
O: No, porque al no ser un problema de optimización, no tiene sentido usar ramificación y poda: se debe usar el método vuelta atrás.
O: Sí, porque se puede usar alguna propiedad de las soluciones parciales para ordenar la búsqueda y reducir el tiempo de cómputo, al evitar visitar partes del espacio de soluciones.
A: 2
C: Julio 2023

Q: ¿Cuál de los siguientes tres problemas de optimización posee una solución voraz exacta?
O: El problema del cambio (formar una suma entera $M$ con el número mínimo de monedas tomadas (con repetición) de un conjunto donde existe una cantidad suficientemente grande de monedas con cada posible valor facial, asumiendo que existen siempre monedas de valor facial unidad y que los contenedores de monedas están previamente ordenados por valor facial.
O: El problema de determinar cómo usar la mínima longitud de línea telefónica para conectar las $n$ casas de una isla.
O: El problema de unir las $n$ casas de una isla con la mínima longitud de línea telefónica, pero formando un ciclo; es decir, de manera que todas las casas están unidas únicamente a otras dos casas de la isla, ni una más ni una menos.
A: 1
C: Julio 2023

Q: En el caso más favorable, ¿cuál es la complejidad temporal que se puede conseguir con una solución de ramificación y poda para el problema del laberinto?
O: $\Omega(m \cdot n)$
O: $\Omega(\max(m,n))$
O: $\Omega(\min(m,n))$
A: 1
C: Julio 2023

Q: Se pretende resolver la versión general del problema del laberinto mediante un algoritmo de búsqueda y enumeración. Para reducir los nodos visitados, utilizamos un almacén de resultados parciales obtenido mediante la técnica de programación dinámica iterativa aplicándola a la versión restringida del mismo problema. El almacén se rellena hacia atrás comenzando en la casilla de salida del laberinto. ¿de qué poda se trata?
O: De una poda basada en la cota optimista.
O: De una poda basada en la cota pesimista.
O: Ninguna de las otras dos opciones es cierta.
A: 1
C: Julio 2023

Q: Dada la versión restringida del problema del laberinto, ¿se podría obtener el camino de salida de longitud mínima haciendo uso únicamente de la versión naive de programación dinámica sin ningún tipo de procesamiento posterior?
O: No, el camino solo puede obtenerse a través del almacén de una versión iterativa o con memoización, en un proceso posterior.
O: Sí, cada vez que se resuelve un subproblema hay que tomar el camino que corresponde a la mejor alternativa de las tres posibles y añadirle las coordenadas del subproblema que se está resolviendo.
O: Sí, el mejor camino puede construirse de forma incremental, paso a paso, añadiendo la siguiente casilla a visitar que corresponde con la mejor alternativa de las tres posibles.
A: 1
C: Julio 2023

Q: Para resolver la versión general del problema del laberinto mediante vuelta atrás, utilizamos el estimador que aparece en el listado. ¿Serviría como cota optimista para cualquier nodo del árbol de búsqueda?
```cpp
using Maze = vector<vector<bool>>;
using Point = tuple<size_t, size_t>;
size_t estimator(const Maze &maze, const Point &p) {
  return max(maze.size() - get<0>(p), maze[0].size() - get<1>(p)) - 1;
}
```
O: No, puesto que no sería una cota optimista válida para todos los nodos.
O: Sí, el estimador por sí solo ya representaría una buena cota optimista.
O: Sí, pero para mejorar la poda habría que sumarle la longitud del camino que representa cada nodo.
A: 2
C: Julio 2023

Q: Las siguientes afirmaciones se refieren a un nodo cualquiera del árbol de búsqueda de ramificación y poda en un problema de minimización. De ellas, o bien dos son ciertas y una es falsa, o bien una es cierta y dos son falsas. Marca la que es diferente a las otras dos.
O: El nodo no es prometedor si su cota pesimista es menor que su cota optimista.
O: El nodo no es prometedor si su cota pesimista es mayor que su cota optimista.
O: El nodo no es prometedor si su cota optimista es mayor que la mejor cota pesimista encontrada hasta el momento.
A: 0
C: Julio 2023

Q: Se pretende resolver la versión general del problema del laberinto. ¿Resultaría útil disponer de un almacén de resultados parciales obtenido mediante la técnica de programación dinámica iterativa aplicándola a la versión restringida del mismo problema?
O: Las otras dos opciones son ambas ciertas.
O: Probablemente sí, rellenando un almacén hacia delante desde la casilla de entrada al laberinto.
O: Probablemente sí, rellenando un almacén hacia atrás comenzando en la casilla de salida del laberinto.
A: 0
C: Julio 2023

Q: ¿Cuál de las siguientes formulaciones expresa mejor la complejidad temporal, en función del parámetro $n$, de la siguiente función? (asumimos que $n$ es potencia exacta de 2)
```cpp
int f(int n) {
  int k = 0;
  for (int i = 2; i <= n; i += 2)
    for (int j = n; j > 0; j -= 2)
      k++;
  return k;
}
```
O: $\sum_{p=2}^{n/2} \frac{p-1}{2}$
O: $\sum_{p=1}^{\log n} 2^{p-1}$
O: $\sum_{p=1}^{\log n} \frac{n}{2}$
A: 2
C: Julio 2023

Q: Se pretende resolver la versión general del problema del laberinto mediante un algoritmo de búsqueda y enumeración. Para reducir los nodos visitados, utilizamos una matriz de enteros donde se almacena la longitud del mejor camino encontrado hasta el momento que llega a cada casilla del laberinto. ¿de qué poda se trata?
O: De una poda basada en la cota optimista.
O: De una poda basada en la cota pesimista.
O: Ninguna de las otras dos opciones es cierta.
A: 2
C: Julio 2023

Q: Se pretende resolver la versión general del problema del laberinto mediante un algoritmo de búsqueda y enumeración. Para agilizar la búsqueda, hemos pensado utilizar una matriz en la que cada casilla $(i,j)$ se inicializa con la solución de la versión restringida del problema asumiendo que el origen del laberinto es $(i,j)$. ¿Qué utilidad puede tener esta matriz?
O: Ninguna, en todo caso habría que inicializar cada casilla $(i,j)$ con la solución de la versión restringida del problema asumiendo que el origen del laberinto es $(0,0)$ y el destino $(i,j)$.
O: A priori poca, ya que cada vez que un nodo visita una casilla $(i,j)$ habría que actualizar la matriz, lo que perjudicaría la eficiencia del algoritmo resultante.
O: Puede resultar eficaz para ajustar la mejor cota pesimista encontrada hasta el momento y además, no es imprescindible actualizar la matriz durante todo el proceso de búsqueda.
A: 2
C: Julio 2023

Q: Con la técnica de programación dinámica aplicada a la versión restringida del problema del laberinto...
O: ...no solo puede obtenerse el camino de salida más corto, también puede obtenerse, sin incrementar la complejidad temporal, el camino más corto desde el origen hasta cualquier casilla accesible del laberinto.
O: ...puede obtenerse el camino más corto desde cualquier casilla accesible hasta la salida si es que existe.
O: Las otras dos opciones son ambas ciertas.
A: 2
C: Julio 2023

Q: Dada la versión restringida del problema del laberinto, ¿se puede modificar la solución de programación dinámica con complejidad espacial reducida para obtener también un camino de salida de longitud mínima?
O: No.
O: Sí, pero a costa de aumentar la complejidad espacial del almacén.
O: Sí, añadiendo un vector de movimientos.
A: 0
C: Julio 2023

Q: El problema de la moneda consiste en formar una suma $M$ con el número mínimo de monedas tomadas (con repetición) de un conjunto donde hay una cantidad suficientemente grande de monedas con cada posible valor facial. Asumiremos que los contenedores de monedas están previamente ordenados por valor facial. ¿Cuál de estas afirmaciones sobre el algoritmo voraz obvio es falsa?
O: Dependiendo de cuáles sean los valores faciales y la suma, puede ser que el algoritmo voraz no encuentre ninguna solución.
O: Dependiendo de cuáles sean los valores faciales y la suma, puede ser que el algoritmo voraz no encuentre la solución que menos monedas usa.
O: Tiene una complejidad temporal $\Theta(M)$.
A: 2
C: Julio 2023

Q: ¿Cuál de las siguientes afirmaciones es cierta sobre la complejidad temporal, en el caso peor, de los algoritmos de vuelta atrás y ramificación y poda aplicados a la versión general del problema de la mochila?
O: Ambos algoritmos tienen la misma complejidad temporal.
O: El algoritmo de vuelta atrás tiene una complejidad temporal peor que el de ramificación y poda.
O: El algoritmo de ramificación y poda tiene una complejidad temporal peor que el de vuelta atrás.
A: 0
C: Julio 2023

Q: Una empresa de transportes dispone de $M$ vehículos para repartir $N$ paquetes, todos al mismo destino. Cada paquete $i$ tiene un peso $P_i$ y se tiene que entregar antes de que transcurra un tiempo $T_{P_i}$. Por otro lado, cada vehículo $j$ puede transportar una carga máxima $C_j$, tarda un tiempo $T_j$ para llegar al destino y consume una cantidad $L_j$ de litros de combustible, independientemente de la carga que transporta. Imaginad un algoritmo de vuelta atrás que obtenga la manera en que se tienen que transportar los objetos (en qué vehículo $j$ tiene que ir cada objeto $i$) para que el consumo sea el mínimo. ¿Cuál sería una buena cota pesimista?
O: La solución voraz del problema de cargar cada paquete en el camión de menor consumo donde cada paquete llega a tiempo, sin tener en cuenta si el camión se sobrecarga o no.
O: La solución voraz del problema de cargar cada paquete en el camión de menor consumo donde cada paquete llega a tiempo, sin sobrecargar ningún camión.
O: Ninguna de las otras dos opciones es correcta.
A: 1
C: Julio 2023

Q: Las siguientes afirmaciones se refieren a un nodo cualquiera del árbol de búsqueda de ramificación y poda en un problema de maximización. De ellas, o bien dos son ciertas y una es falsa, o bien una es cierta y dos son falsas. Marca la que es diferente a las otras dos.
O: Si su cota pesimista es menor que el mejor valor encontrado hasta el momento, entonces el nodo no podrá mejorar dicho valor.
O: Si su cota optimista es menor que el mejor valor encontrado hasta el momento, entonces el nodo no podrá mejorar dicho valor.
O: Su cota optimista es un valor que podría llegar a alcanzarse.
A: 0
C: Julio 2023

Q: Debemos calcular $A^n$, donde $A$ una matriz de $m \times m$ elementos. ¿Existe una solución que evite realizar $n - 1$ multiplicaciones de coste $m^3$?
O: No, la única manera de calcular $A^n$ es iterativamente, $A^n = AA^{n-1}$ y se deben realizar $n - 1$ multiplicaciones.
O: Sí, existe una solución más eficiente del estilo "divide y vencerás", que usa un espacio $\Theta(m^3 \log n)$.
O: Sí, existe una solución más eficiente del estilo "divide y vencerás", que usa un espacio $\Theta(m^3 n)$.
A: 1
C: Julio 2023

Q: Sean dos funciones de coste $f : \mathbb{N} \to \mathbb{R}^+$ y $g : \mathbb{N} \to \mathbb{R}^+$ tales que $f \in O(g)$. De las siguientes situaciones, o bien dos pueden suceder y la otra no, o bien dos no pueden suceder y la otra sí. Indica la que es diferente de las otras dos.
O: $\lim_{n \to \infty} \frac{g(n)}{f(n)} = \infty$
O: $\lim_{n \to \infty} \frac{g(n)}{f(n)} = k, k \in \mathbb{R}^+, k \neq 0$
O: $\lim_{n \to \infty} \frac{g(n)}{f(n)} = 0$
A: 1
C: Julio 2023

Q: Una de las siguientes afirmaciones es cierta. Di cuál.
O: $\Theta(2^n) \neq \Theta(3^n)$
O: $O(2^n) \subset O(n^2)$
O: $\Omega(2^n) \subset \Omega(n!)$
A: 0
C: Julio 2023

Q: La distancia de Manhattan $(d)$ entre dos puntos $(x_1, y_1)$ y $(x_2, y_2)$ viene dada por la expresión $d = |x_1 - x_2| + |y_1 - y_2|$. ¿Podría utilizarse como cota optimista para resolver la versión general de problema del laberinto?
A: 0
C: Junio 2023
O: No, puesto que incumple la condición para ser una cota optimista correcta.
O: Sí, pero hay otros estimadores que se suelen comportar mejor ante este problema.
O: Sí, y además tiene la ventaja de que se puede calcular con complejidad temporal constante.

Q: Dada la versión general del problema del laberinto, se pretende resolver mediante vuelta atrás haciendo uso de un mecanismo de poda basado en la mejor solución encontrada hasta el momento. ¿Cuándo se podaría un nodo?
A: 0
C: Junio 2023
O: Cuando el valor de su cota optimista supere al valor de la mejor cota pesimista encontrada hasta el momento.
O: Cuando el valor de su cota pesimista supere al valor de su cota optimista.
O: Cuando el valor de su cota optimista supere al valor de su cota pesimista.

Q: Sea el vector $v = \{1, 3, 2, 7, 4, 6, 8\}$ cuyos elementos están dispuestos formando un montículo de mínimos. Posteriormente añadimos en la última posición del vector un elemento nuevo con valor 5. ¿Qué operación hay que hacer para que el vector siga representando un montículo de mínimos?
A: 0
C: Junio 2023
O: Intercambiar el 7 con el 5.
O: Intercambiar el 8 con el 5.
O: No hay que hacer nada pues el vector $v = \{1, 3, 2, 7, 4, 6, 8, 5\}$ también es un montículo de mínimos.

Q: Se dispone de un conjunto de $n$ valores numéricos dispuestos en forma de montículo y se desea obtener el valor de la suma de todos los que al menos tienen un hijo (es decir, no son nodos hoja). ¿Cuál es la complejidad temporal del mejor algoritmo que se puede escribir?
A: 0
C: Junio 2023
O: $O(n)$
O: $O(\log n)$
O: $O(n \log n)$

Q: ¿De qué clase de complejidad es la solución de la siguiente relación de recurrencia?
$f(n) = n(n-1) + f(n-1)$ si $n > 0$
$f(0) = 1$ si $n = 0$
A: 1
C: Junio 2023
O: $f(n) \in \Theta(n^2)$
O: $f(n) \in \Theta(n^3)$
O: Ninguna de las otras dos opciones es cierta.

Q: Indica cuál es la complejidad temporal en función de $n$, donde $A$ es un vector de enteros y $k$ es una constante que no depende de $n$, del fragmento siguiente:
```cpp
for (int i = k; i < n - k; i++) {
  A[i] = 0;
  for (int j = i - k; j < i + k; j++)
    A[i] += B[j];
}
```
A: 2
C: Junio 2023
O: $\Theta(k)$
O: $\Theta(n^2)$
O: $\Theta(n)$

Q: Con respecto a la técnica poda con memoria, solo una de las siguientes afirmaciones es cierta. ¿Cuál es?
A: 2
C: Junio 2023
O: No resulta eficaz para resolver la versión general del problema del laberinto mediante ramificación y poda.
O: No se puede aplicar para resolver la versión restringida del problema del laberinto.
O: En una solución de vuelta atrás para la versión general del problema del laberinto, sirve también para descartar ciclos.

Q: Se pretende resolver la versión general del problema del laberinto mediante ramificación y poda. Para obtener la cota optimista de un nodo cualquiera procedemos así: calculamos el menor número de casillas que quedan, por la diagonal o derecha-abajo, hasta llegar a una pared del laberinto. A ese valor le sumamos el número de casillas que podrían quedar desde esa pared hasta la salida utilizando únicamente movimientos del tipo abajo o derecha, según corresponda. ¿Qué podemos decir acerca de la cota optimista que se obtendría?
A: 2
C: Junio 2023
O: Que no cumple la condición para ser una cota optimista correcta.
O: Que no sería eficiente con respecto a otras cotas optimistas, ya que su cálculo requiere una complejidad temporal que no es constante.
O: Que es una cota optimista correcta y además puede obtenerse con complejidad temporal constante.

Q: ¿Qué inconveniente presenta la siguiente función?
```cpp
void maze(const Maze &maze, vector<vector<bool>> &visited, Point &currentPoint,
          size_t currentLength, size_t &currentBestLength) {
  if (currentPoint == maze.exit()) {
    currentBestLength = min(currentBestLength, currentLength);
    return;
  }
  for (auto step : allSteps) {
    Point next = currentPoint.next(step);
    if (maze.is_valid(next) && !visited[next.x()][next.y()] &&
        currentLength < currentBestLength) {
      visited[next.x()][next.y()] = true;
      maze(maze, visited, next, currentLength + 1, bestLength);
      visited[next.x()][next.y()] = false;
    }
  }
  return;
}
```
A: 2
C: Junio 2023
O: Que no detecta todos los subproblemas repetidos que pueden aparecer.
O: Que la poda basada en la mejor solución hasta el momento se puede mejorar fácilmente.
O: Las otras dos opciones son ambas ciertas.

Q: Con los valores numéricos almacenados en un fichero, queremos construir un heap (montículo). ¿cuál es la forma más eficiente de proceder?
A: 0
C: Junio 2023
O: Almacenar esos valores en un vector y después, reorganizar sus elementos para que estén dispuestos en forma de heap.
O: Almacenar esos valores directamente en un heap que inicialmente está vacío y va creciendo por cada uno de los valores insertados.
O: Ambas formas de proceder son equivalentes en cuanto a eficiencia.

Q: Se dispone de un conjunto de $n$ valores numéricos dispuestos en un vector sin orden preestablecido. Se desea escribir una función que reciba ese vector y un valor $k$ $(n/2 \leq k \leq n)$ y que devuelva los $k$ valores más pequeños dispuestos en otro vector de manera ordenada. ¿Cuál es la complejidad temporal del mejor algoritmo que se puede escribir?
A: 1
C: Junio 2023
O: $O(kn)$
O: Ninguna de las otras dos opciones es cierta.
O: $O(k \log n)$

Q: Se pretende resolver la versión general del problema del laberinto mediante ramificación y poda y para ello se usa una estrategia que consiste en priorizar las expansiones de los nodos que contienen un camino explorado más corto. ¿Qué podemos decir del algoritmo resultante?
A: 2
C: Junio 2023
O: Que la primera hoja a la que se llegue es la solución del problema y por lo tanto, ya no será necesario explorar más nodos de la lista de nodos vivos, aunque no esté vacía.
O: Que el recorrido en el árbol de búsqueda será equivalente a un recorrido por niveles, por lo que no es necesario utilizar una cola de prioridad.
O: Las otras dos opciones son ambas ciertas.

Q: Dada la versión restringida del problema del laberinto, estamos interesados en obtener, para cada casilla accesible del laberinto, el camino más corto entre el origen y esa casilla. ¿Qué esquema es el más apropiado en este caso?
A: 0
C: Junio 2023
O: La versión iterativa de programación dinámica.
O: Memoización.
O: Ambas técnicas resultan equivalentes.

Q: Dada la versión general del problema del laberinto ¿Qué ocurre si la cota optimista de un nodo resulta ser el valor que se obtiene de una solución factible pero que no es la mejor en el subárbol generado por ese nodo?
A: 1
C: Junio 2023
O: Nada especial, las cotas optimistas se corresponden con soluciones factibles que no tienen por qué ser las mejores.
O: Que el algoritmo sería incorrecto pues podría descartarse el nodo que conduce a la solución óptima.
O: Que el algoritmo sería más lento pues se explorarían más nodos de los necesarios.

Q: Con respecto a los algoritmos estudiados durante el curso que encuentran el árbol de recubrimiento de mínimo coste, de las afirmaciones siguientes, o bien dos son verdaderas y una es falsa, o bien dos son falsas y una es verdadera. Marca la que (en este sentido) es diferente de las otras dos.
A: 0
C: Junio 2023
O: El algoritmo de Kruskal va construyendo un bosque de árboles que va uniendo hasta que acaba con un árbol de recubrimiento de coste mínimo.
O: El algoritmo de Prim se puede acelerar notablemente si los vértices se organizan en una estructura union-find.
O: La complejidad temporal del algoritmo de Prim es cúbica con respecto al número de vértices del grafo.

Q: ¿Cuál es la complejidad, en función de $n$, del siguiente fragmento:
(suponed que A está definido como `vector<int>&A(n)` y `sort()` es la función de ordenación de la librería estándar de C++, que tiene la mejor complejidad, temporal y espacial, posible para un algoritmo de ordenación de propósito general)
```cpp
std::sort(begin(A), end(A));
int acc = 0;
for (auto i : A)
  acc += i;
```
A: 0
C: Junio 2023
O: $\Theta(n \log n)$
O: $\Theta(n^2)$
O: $\Theta(n)$

Q: Una empresa de transportes dispone de $M$ vehículos para repartir $N$ paquetes, todos al mismo destino. Cada paquete $i$ tiene un peso $P_i$ y se tiene que entregar antes de que transcurra un tiempo $T_P_i$. Por otro lado, cada vehículo $j$ puede transportar una carga máxima $C_j$, tarda un tiempo $T_j$ para llegar al destino y consume una cantidad $L_j$ de litros de combustible, independientemente de la carga que transporte. Imaginad un algoritmo de vuelta atrás que obtenga la manera en que se tienen que transportar los objetos (en qué vehículo $j$ tiene que ir cada objeto $i$) para que el consumo sea el mínimo. ¿Cuál sería una buena cota optimista?
A: 2
C: Junio 2023
O: La solución voraz del problema de cargar cada paquete en el camión de menor consumo donde cada paquete llega a tiempo, sin tener en cuenta si el camión se sobrecarga o no.
O: La solución voraz del problema de cargar cada paquete en el camión de menor consumo, sin sobrecargarlo, sin tener en cuenta si el paquete llega a tiempo o no.
O: Ambas son cotas optimistas válidas.

Q: ¿Qué hace la siguiente función?
```cpp
void f(vector<int> &A) {
  priority_queue<int> pq;
  for (auto i : A)
    pq.push(A[i]);
  A.clear();
  while (!pq.empty()) {
    A.push_back(pq.top());
    pq.pop();
  }
}
```
A: 2
C: Junio 2023
O: Invierte el vector A (el último elemento quedará el primero).
O: Nada, deja el vector A como estaba.
O: Ordena el vector A.

Q: Dada la versión restringida del problema del laberinto, si solo se desea conocer la longitud del camino de salida más corto, ¿cuál es la mejor complejidad temporal y espacial que se puede conseguir si se aplica programación dinámica?
A: 0
C: Junio 2023
O: Temporal $\Theta(mn)$ y espacial $\Theta(\min[n, m])$
O: Ninguna de las otras dos opciones es cierta.
O: Temporal $\Theta(mn)$ y espacial $\Theta(mn)$

Q: Queremos aplicar la técnica de memoización a la siguiente función recursiva:
```cpp
double f(double x) {
  if (x <= 2)
    return x;
  return f(sqrt(x - 1)) + f(sqrt(x - 2));
}
```
¿Cuál sería un buen candidato para el almacén?
(La función `sqrt()` obtiene la raíz cuadrada; xMax es el valor de x en la primera llamada.)
A: 2
C: Junio 2023
O: `vector<vector<double>> M(xMax+1,vector<double>(xMax+1))`
O: `vector<double> M(xMax+1)`
O: Ninguna de las otras dos opciones es válida.

Q: Dada la versión general del problema del laberinto, tratamos de completar un nodo cualquiera del árbol de búsqueda con el camino que, en caso de existir, obtendríamos asumiendo solo los tres movimientos de la versión restringida. ¿Qué obtendríamos en el caso de completar el nodo?
A: 1
C: Junio 2023
O: Una cota optimista para ese nodo.
O: Un nodo hoja del subárbol generado por aquel nodo.
O: Nada de interés, puesto que el camino resultante no contemplaría todos los movimientos permitidos.

Q: Dada la versión restringida del problema del laberinto, ¿se podría modificar la solución naïve de divide y vencerás para que obtenga el número total de caminos diferentes, de cualquier longitud, que conducen a la salida desde el origen?
A: 2
C: Junio 2023
O: No se puede, ya que no se trataría de un problema de optimización.
O: No se puede, puesto que se trata de un nuevo problema que no cumple las condiciones de aplicación de divide y vencerás.
O: Sí, pero puesto que se trata de un nuevo problema, hay que cambiar la recurrencia matemática inicial.

Q: ¿Qué obtenemos con la siguiente declaración de C++: `priority_queue<nodo> pq;`?
A: 0
C: Junio 2023
O: Un heap o montículo de máximos.
O: Un heap o montículo de mínimos.
O: Un heap o montículo sin orden establecido ya que no se ha definido la función de comparación.

Q: Estamos resolviendo la versión restringida del problema del laberinto. Ya hemos obtenido el almacén de resultados parciales. ¿Con qué complejidad temporal podemos obtener un camino de salida de longitud mínima si es que existe?
A: 0
C: Junio 2023
O: $\Theta(m + n)$
O: $\Omega(\min(n, m))$ y $O(mn)$
O: $\Theta(mn)$

Q: Se pretende resolver la versión general del problema del laberinto mediante un algoritmo de búsqueda y enumeración. Para reducir el número de nodos explorados, ¿qué mecanismo de los relacionados garantiza encontrar la solución y resulta a priori más eficaz?
A: 2
C: Junio 2023
O: Usar una matriz de booleanos para descartar caminos que llegan a una casilla ya visitada. Cada casilla $(i, j)$ de la matriz se inicializa con el valor false.
O: Usar una matriz de enteros donde se almacena la longitud del mejor camino encontrado hasta el momento que llega a cada casilla del laberinto. Cada casilla $(i, j)$ de la matriz se inicializa con el valor infinito.
O: Usar una matriz de enteros donde se almacena la longitud del mejor camino encontrado hasta el momento que llega a cada casilla del laberinto. Cada casilla $(i, j)$ de la matriz se inicializa con la solución de programación dinámica para la versión restringida del problema asumiendo que el destino es $(i, j)$.

Q: ¿Cuál es la característica principal de un algoritmo voraz aplicado al problema del laberinto?
A: 1
C: Junio 2023
O: Explora exhaustivamente todas las posibles soluciones del laberinto.
O: Toma decisiones locales óptimas en cada paso sin considerar el panorama general.
O: Utiliza una estrategia basada en estimaciones heurísticas para encontrar la solución óptima.

Q: Un fontanero tiene una jornada de $Q$ cuartos de hora (es así como se organiza la agenda) y tiene $C$ clientes. El trabajo del cliente $i$ tarda $q_i$ cuartos de hora y el fontanero le cobra un precio $p_i$. Es posible que no pueda atender todos los clientes en la jornada, que nunca puede alargarse. Este problema tiene una solución bien conocida que permite elegir qué clientes visitar para que la suma cobrada al final de la jornada sea la máxima. ¿Qué podemos decir de esta solución?
A: 1
C: Junio 2023
O: Que se ha de implementar forzosamente con un algoritmo de búsqueda y enumeración como el de vuelta atrás.
O: Que la organización de la agenda en cuartos de hora permite obtener una solución de complejidad temporal $\Theta(QC)$ y complejidad espacial $O(Q)$.
O: Que no se puede implementar con una solución de "divide y vencerás" con memoización.

Q: Dada la versión restringida del problema del laberinto, ¿cuál de las estrategias siguientes proveería de una cota optimista para ramificación y poda?
A: 1
C: Junio 2023
O: Suponer que en adelante todas las casillas del laberinto son accesibles.
O: Las otras dos estrategias son ambas válidas.
O: Suponer que ya no se van a realizar más movimientos.

Q: De las siguientes expresiones, o bien dos son ciertas y una es falsa, o bien al contrario, una es cierta y dos son falsas. Marca la que en este sentido es diferente a las otras dos.
A: 1
C: Junio 2023
O: $\sum_{i=1}^{n/2} \sum_{j=1}^{i} 2^j \in O(n \log n)$
O: $\sum_{i=1}^{n} \sum_{j=1}^{\log i} 2^j \in O(n^2)$
O: $\sum_{i=1}^{\log n} \sum_{j=1}^{n} 2^j \in O(n \log n)$

Q: En cuanto a la posibilidad de aplicar la técnica de programación dinámica iterativa para resolver un problema:
A: 0
C: Junio 2023
O: Se debe conocer de antemano todos los posibles subproblemas y además, se debe disponer de una ordenación entre todos ellos según tamaño.
O: No necesariamente ha de conocerse de antemano todos los posibles subproblemas pero sí debe saberse, dados dos de ellos cualesquiera, cuál es más pequeño.
O: Se debe conocer de antemano todos los posibles subproblemas pero no necesariamente se debe disponer de una ordenación entre todos ellos según tamaño.

Q: ¿Cuál de los siguientes enfoques es más eficiente para resolver la versión restringida del problema del laberinto?
A: 1
C: Junio 2023
O: Enfoque voraz.
O: Enfoque de programación dinámica.
O: Enfoque de vuelta atrás.

Q: ¿Cuál es el coste de monticulizar (heapify) un vector de tamaño $N$?
A: 1
C: Junio 2023
O: $O(N \log N)$ y $\Omega(N)$
O: $\Theta(N)$
O: $O(N)$ y $\Omega(1)$

Q: Para resolver la versión general del problema de la mochila con $n$ objetos y carga máxima $W$, hemos escrito un algoritmo de divide y vencerás que, sucesivamente, divide el problema en dos subproblemas; cada uno de ellos toma la mitad de los objetos y la mitad de la carga máxima de la mochila. El caso base ocurre cuando solo hay un objeto que se añade a la solución si cabe en la fracción de carga máxima que corresponda a ese subproblema, y si no cabe se descarta. Asumiendo que $n$ y $W$ son potencias exactas de 2, ¿qué podemos decir de esta solución?
A: 0
C: Junio 2023
O: Que con los resultados de los subproblemas no siempre se puede componer la solución del problema original.
O: Que no cumple el teorema de reducción.
O: Que, aunque con los resultados de los subproblemas se puede componer la solución del problema original, esta formulación no mejora la solución estudiada en clase.

Q: ¿Cómo se utiliza la cola de prioridad en el algoritmo de ramificación y poda para resolver el problema del laberinto?
A: 1
C: Junio 2023
O: Se agregan los nodos a la cola de prioridad en orden aleatorio para explorar todas las posibilidades.
O: Los nodos se agregan a la cola de prioridad según una estimación heurística para priorizar los caminos más prometedores.
O: Los nodos se extraen de la cola de prioridad según se vayan obteniendo.

Q: En un algoritmo de búsqueda y enumeración, ¿qué podemos decir acerca de la heurística que se utiliza para determinar si un nodo debe expandirse o no?
A: 1
C: Junio 2023
O: Que puede equivocarse, por eso se le llama heurística.
O: Que también puede usarse como estrategia de búsqueda.
O: Las otras dos opciones son ambas ciertas.

Q: Dados dos nodos cualesquiera del árbol de búsqueda de ramificación y poda, en general, ¿se puede saber con certeza cuál está más cerca de la solución óptima del problema a resolver?
A: 2
C: Junio 2023
O: Sí, el que tiene mejor cota optimista.
O: Sí, el que tiene mejor cota pesimista.
O: Sí, pero solo si ambos nodos son hoja.

Q: El problema de la moneda consiste a formar una suma $M$ con el número mínimo de monedas tomadas (con repetición) de un conjunto $C$ donde hay una cantidad suficientemente grande de monedas con cada posible valor facial $C = \{c_1, c_2, \ldots, c_{|C|}\}$, con $c_1 = 1$. ¿Cuál de estas afirmaciones sobre un algoritmo recursivo de la forma:
$n_{opt}(M) = 1 + \min_{1 \leq i \leq |C|} n_{opt}(M - c_i); n_{opt}(0) = 0; n_{opt}(x) = \infty$ para $x < 0$
es falsa?
A: 0
C: Junio 2023
O: Dependiendo de cuáles sean los valores faciales y la suma, puede ser que el algoritmo recursivo no encuentre solución.
O: Tiene un coste temporal prohibitivo, ya que puede calcular $n_{opt}(x)$ para el mismo valor de $x$ más de una vez.
O: Encuentra siempre la solución óptima.

Q: Se pretende resolver el problema del viajante de comercio (travelling salesman problem) mediante el esquema de vuelta atrás. ¿Cuál de los siguientes valores se espera que se comporte mejor como cota optimista para un nodo?
A: 0
C: Junio 2023
O: La suma de los pesos de las $k$ aristas restantes más cortas, donde $k$ es el número de ciudades que quedan por visitar.
O: El valor que se obtiene de multiplicar $k$ por el peso de la arista más corta de entre las restantes, donde $k$ es el número de ciudades que quedan por visitar.
O: La suma de los pesos de las aristas que completan la solución paso a paso visitando el vértice más cercano al último visitado.

Q: Dada la solución naïve de la versión restringida del problema del laberinto, en general, ¿cuántas veces se llega al caso base de la recursión?
A: 1
C: Junio 2023
O: Solo una.
O: Un valor que puede crecer exponencialmente con el tamaño del laberinto.
O: Un valor que a lo sumo es $n \cdot m$.

Q: ¿Cuál es la complejidad temporal en función de $n$, del siguiente fragmento:
```cpp
for (int i = 0; i < n; i++) {
  A[i] = 0;
  for (int j = 0; j < 20; j++)
    A[i] += B[j];
}
```
A: 2
C: Junio 2023
O: $\Theta(n \log n)$
O: $\Theta(n^2)$
O: $\Theta(n)$
