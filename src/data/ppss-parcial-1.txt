Indica cual de las siguientes afirmaciones es falsa acerca del uso de categorías en jUnit
3
Se anota como categoría un método anotado como @test
Se anota como categoría varios drivers de una clase
Se anota como categoría una interfaz
Se anota como categoría una clase que contiene drivers

Dado el siguiente driver para probar metodoSUT():```@Test (expected =MiExcepcion.class) \nPublic void testC1(){ \n\tInt resultadoEsperado =0; \n\tInt resultadoReal = metodoSut(); \n\tAssertEquals(resultadoEsperado, resultadoReal); \n}``` (no seguro)
3
Error, si el metodoSUT() provoca la excepción MiExecpcion.class
Passed, si el metodoSUT() provoca la excepción MiExecpcion.class
Passed, si el metodoSUT() devuelve 0
Failed, si el metodoSUT() provoca la excepción MiExecpcion.class

Indica cual de las siguientes afirmaciones es cierta con respecto a estos 3 tipos de objetoPodemos crear una librería EasyMock: NiceMock, mock y StrictMock
3
Con los tipos Mock y NiceMock se lanza un AssertionError si no hemos programado las expect.. dealgún método
Con los tres tipos se verifica si todas las llamadas esperadas a métodos realizadas por el doblerealizan con los argumentos especificados
Con los tres tipos siempre hay que invocar al método replay() de la librería.
Con los tipos Mock y StrictMock se verifica el orden en el que se realizan las invocaiones al doble

Con respecto al método de caja negra de particiones equivalente, indica cual de las siguientes afirmaciones es cierta:
2
Todas las entradas y salidas se corresponden con parámetros de la SUT
Dos elementos de la misma partición de entrada no se pueden corresponder con dos elementos departiciones de salida diferentes
Las particiones pueden compartir elementos para mantener algunos datos de prueba redundantes
Se deben probar todas las posibles combinaciones de las particiones

Cualquier librería que sea requerida en el proceso de construcción de un proyecto Maven
3
si no se encuentra en un repositorio remoto, se busca en el repositorio local
si se encuentra en un repositorio remoto, se descarga en el directorio target
todas las afirmaciones anteriores son falsas
si no se encuentra en un repositorio remoto, se busca en el directorio .m2

Utilizando un método de caja negra de particiones equivalentes si tenemos una entrada asociada a un tipoenumerado con 3 valores, indica cual de las siguientes afirmaciones es falsa
4
Podemos tener dos particiones validas de dicha entrada
Podemos tener una sola partición valida de dicha entrada
Podemos tener tres particiones validas de dicha entrada 
Podemos tener tres particiones no validas de dicha entrada

Si al aplicar el método de caja negra de particiones equivalentes obtendremos las siguientes particiones de entrada, validas y no validas, teniendo en cuenta la siguiente codificación para identificar las particiones “E” denota entrada,“V” denota valida y “nV” denota no valida. ```Entrada 1 : “E1V1, E1V2, E1nV1” \nEntrada 2 : “E2V1, E2nV1, E2nV2” ```Indica cual es la cardinalidad del conjunto de casos de prueba eficiente y efectivo al aplicar dicho método:
2
4
5
No se puedo obtener si no se conocen las particiones de salida validas y no válidas.
6

En un método de diseño de pruebas basado en el flujo de control del código, un camino imposible detectado
1
No se asocia a ningún caso de prueba
Se asocia a un caso de prueba con un resultado esperado desconocido
Se asocia a un caso de prueba con valores de entrada desconocidos
Todas las afirmaciones del resto de opciones son falsas

Cuando refactorizamos la SUT para poder inyectar el doble:
3
Añadimos un método setter estamos obligando a cualquier código cliente de la SUT a conocer dicha dependencia antes de invocarla
Si añadimos un parámetro a la SUT estamos obligados a declarar la dependencia como un atributo de la clase que contiene la SUT
Si añadimos una factoria local, alteramos el comportamiento de la clase que contiene la SUT
Si añadimos una clase factoria no se altera el código de producción

Indica las líneas en las que identificamos las dependencias externas de la SUT calculaConsumo():```## paquete ppsss.ejercicio2 \npublic class GestorLLamadas {  \n\tprivate static final double TARIFA_NOCTURNA=10.5;  \n\tprivate static fianl double TARIFA_DIURNA=20.8;  \n\t \n\tpublic Calendario getCalendario(){  \n\t\tCalendario c = new Calendario();  \n\t\treturn c;  \n\t}  \n\t \n\tpublic double calculaConsumo( int minutos){ \n\t\tCalendario c = getCalendario(); \n\t\tint hora = c.getHoraActual(); \n\t\tif(hora < 8 || hora > 20){ \n\t\t\treturn minutos * TARIFA_NOCTURNA; \n\t\t}else{  \n\t\t\treturn minutos * TARIFA_DIURNA; \n\t\t} \n\t} \n}```
4
En las líneas 7, 12, y 13
Solo en la línea 13
En las líneas 7 y 12
En las líneas 12 y 13

El comando nvm de Maven
3
Sirve para ejecutar fases, pero no goals
Sirve para ejecutar goals pero no fases
Se ejecuta desde el directorio donde se encuentra el fichero de configuración del proyecto Maven
Se ejecuta desde el directorio src para compilar los ficheros fuentes y desde el directorio test paracompilar los ficheros con las pruebas

Dado el siguiente diagrama de Venn que hemos trabajado en clase: \n![Diagrama](/data/images/ppss-p1-1.png){width=200 height=200}\n Indica cual de las siguientes afirmaciones es cierta:
2
Un tester debe intentar que el subconjunto 7 sea lo más grande posible
Con métodos de caja negra y de caja blanca, se pueden alcanzar comportamientos de los subconjuntos 1 y 2
Con un método de caja negra se pueden alcanzar comportamientos del subconjunto 3
Con un método de caja blanca se pueden alcanzar comportamientos del subconjunto 4

Si en el pom.xml de nuestro proyecto añadimos la siguiente propiedad:```<properties> \n\t<miPropiedad>misTests</miPropiedad> \n</properties>``` y la siguiente configuración del plugin maven-surefire-plugin: ```<configuration> \n\t<groups>${miPropiedad}</groups> \n</configuration>``` y tiene la siguiente clase para los tests con 3 drivers:```class MiClaseTest { \n\t@Tag("misTests") \n\t@Test void test1() { } \n\t\t## aquí vendría el código del test \n\t} \n\t\n\t@Tag("otroTest") \n\t@Test void test2() { } \n\t\t## aquí vendría el código del test \n\t} \n\t\n\t@Test void test3() { } \n\t\t## aquí vendría el código del test \n\t} \n} ```Si desde la línea de comandos ejecutamos la orden: \nmvn test -Dgroups=""
1
Se ejecutan los 3 drivers
No se ejecuta ningún driverpor que en la orden no se indicaninguna etiqueta
Se ejecuta solo test3()
Se ejecuta solo test1()

Con cual de los siguientes comando de Maven no se ejecutarían las pruebas unitarias:
1
Mvn clean compile surefire:test
Mvn test
Mvn clean test-compile surefire:test
Mvn test-compile surefire:test

Indica cuál de las siguientes afirmaciones es falsa:
4
Durante el proceso de desarrollo de un producto, cuanto antes se detecte un defecto menos costososserá repararlo
Aunque un producto funcione de acuerdo con los requerimientos especificados puede que nosatisfaga las expectativas del cliente
Aunque probemos un código utilizando un conjunto de pruebas eficiente y efectivo y todos los testpases, no podemos garantizar que el código no presenta ningún defecto
Las pruebas pueden demostrar la ausencia de defectos

Indica cual de las siguientes afirmaciones es falsa acerca del uso de categorías en jUnit
2
Se anota como categoría varios drivers de una clase
Se anota como categoría una interfaz
Se anota como categoría un método anotado como @test
Se anota como categoría una clase que contiene drivers

El método de diseño de transición de estados
3
Requiere que hayamos implementado todas las unidades para poder aplicarlo
Al igual que el método del camino básico se aplica en pruebas dinámicas
Es un método funcional y por lo tanto lo podemos aplicar en cualquier nivel de pruebas
Representa las transiciones a partir de entradas y acciones

Indica cuál de las siguientes afirmaciones es falsa con respecto al uso de un objeto de tipo IMocksControl:
3
no permite el uso de partial mock
permite chequear el orden de invocaciones entre varios dobles
no permite el uso de verify()
permite chequear el orden de las invocaciones de un doble

Al ejecutar una clase de test que contiene n drivers:
3
el método anotado con @BeforeEach se ejecuta n-1 veces
el método anotado con @AfterAll se ejecuta n veces
el método anotado con @BeforeAll se ejecuta una vez
el método anotado con @AfterEach se ejecuta n-1 veces

De los siguientes comandos de maven, ¿cuáles no ejecutarán los tests unitarios? \n\nComando 1: mvn clean surefire:test \nComando 2: mvn clean test \nComando 3: mvn test \Comando 4: mvn clean compile surefire:test \nComando 5: mvn clean test surefire:test
4
los comandos 2 y 3
los comandos 1, 2, 4 y 5
los comandos 1, 4 y 5
los coamndos 1 y 4

Con el método del camino básico de McCabe:
2
debemos elegir el conjunto mínimo de caminos para conseguir que todas las sentencias se ejecuten al menos una vez en cada caso de prueba
todas las afirmaciones del resto de opciones son falsas
debemos elegir el conjunto mínimo de caminos para conseguir ejecutar todas las condiciones al menos una vez en cada caso de prueba
debemos elegir todos los caminos del grafo

Para realizar pruebas de una SUT que contiene dependencias externas,
3
usaremos una verificación basada en el estado para pruebas unitarias, y una verificación basada en el comportamiento para pruebas de integración
todas las afirmaciones del resto de opciones son talsas
el primer paso es identificar los seams que contiene la SUT
no está permitido modificar la SUT de ninguna forma para realizar pruebas unitarias

Para realizar pruebas unitarias utilizando verificación basada en el comportamiento de la SUT calcularPrecio(), indica los tipos y números de mocks necesarios: ```public class Ticket {\n\tprivate float precio_final; \n\t//getters y setters \n}``` ```public class AlquilaCoches {\n\tprotected Calendario calendario = new Calendario();\n\n\tpublic Ticket calculaPrecio(TipoCoche tipo, LocalDate inicio, int ndias) throws Mensaje Exception {\n\n\tTicket ticket = new Ticket();\n\tfloat precioDia, precioTotal = 0.0f;\n\tfloat porcentaje = 0.25f;\n\n\tString observaciones = "";\n\tIService servicio = new Servicio();\n\tprecioDia = servicio.consultaPrecio(tipo);\n\tfor (int i=0; i<ndias; i++) {\n\t\tLocalDate otroDia = inicio.plusDays((long) i);\n\t\ttry {\n\t\t\tif (calendario.es_festivo(otroDia)) {\n\t\t\t\tprecioTotal += (1 + porcentaje) * precioDia;\n\t\t\t} else {\n\t\t\t\tprecioTotal += (1 - porcentaje) * precioDia;\n\t\t\t}\n\t\t} catch (CalendarioException ex) {\n\t\t\tobservaciones += "Error en dia: "+otroDia+";";\n\t\t}\n\t}\n\n\tif (observaciones.length() > 0) {\n\t\tthrow new MensajeException(observaciones);\n\t}\n\n\tticket.setPrecio_final(precioTotal);\n\treturn ticket;\n\t}\n}```
4
un PartialMock y dos StrictMock
un StrictControl, un PartialMock y un Mock
un StrictControl, un PartialMock y dos Mock
un StrictMock, un PartialMock y un Mock

![Diagrama](/data/images/ppss-p1-2.png){width=200 height=200}\nSeleccione una: 
4
En las lineas 14 y 18
Dejo la pregunta en blanco
En las lineas 10 y 14
En las lineas 11 y 18

De los siguientes comandos de maven, ¿cuáles generan el .jar del proyecto? \n\nComando 1: mvn clean compiler:testCompile package \nComando 2: mvn clean compile package \nComando 3: mvn clean test-compile package \nComando 4: mvn clean verify \nmvn clean compiler:compile verify \n\nSeleccione una:
4
todos los comandos
los comandos 1, 2 y 3
los comandos 4 y 5
 los comandos 2, 3, 4 y 5

Dado el siguiente método, que devuelve el sumatorio desde 1 hasta un determinado valor n:```int sumatorio(int n) {\n\tint suma = 0;\n\tfor (int i=1; i<= n; i++){\n\t\tsuma +=i;\n\t}\n\treturn suma;\n}```\n\nSe puede aplicar el método del camino básico
1
con uno o 2 caminos
al contener un bucle cuyo número de iteraciones depende del valor de entrada n, no podemos saber el número de caminos
con n caminos
con más de 2 caminos

De los siguientes comandos de maven, ¿cuáles no ejecutarán los tests unitarios? \n\nComando 1: mvn clean surefire:test \nComando 2: mvn clean test \nComando 3: mvn test \Comando 4: mvn clean compile surefire:test \nComando 5: mvn clean test surefire:test
1
los comandos 2, 3 y 5
los comandos 1, 2, 4 y 5
los comandos 1, 4 y 5
los coamndos 4 y 5

Para realizar pruebas unitarias utilizando verificación basada en el comportamiento de la SUT compruebaPremio(), indica los tipos y número de mocks necesarios \n```public class Premio {\n\tprivate static final float PROBABILIDAD_PREMIO = 0.1f;\n\tpublic Random generador = new Random(System.currentTimeMillis());\n\tpublic ClienteWebService cliente = new ClienteWebService();\n\n\tpublic String compruebaPremio() {\n\t\tif(generaNumero() < PROBABILIDAD_PREMIO) {\n\t\t\ttry {\n\t\t\t\tString premio = cliente.obtenerPremio();\n\t\t\t\treturn "Premiado con " + premio;\n\t\t\t} catch(ClienteWebServiceException e) {\n\t\t\t\treturn "No se ha podido obtener el premio";\n\t\t\t}\n\t\t} else {\n\t\t\treturn "Sin premio";\n\t\t}\n\t}\n\n\t## Genera numero aleatorio entre 0 y 1\n\tpublic float generaNumero() {\n\t\treturn generador.nextFloat();\n\t}\n}```
2
un PartialMock y un Mock
un StrictControl, un PartialMock y un Mock
un PartialMock y un StrictMock
un StrictControl y dos StrictMock

Indica cuál de las siguientes afirmaciones es cierta:
3
si es necesario, se puede alterar temporalmente el código de la SUT para realizar pruebas
si es necesario, refactorizamos la SUT para eliminar sus dependencias externas
un doble reemplaza al código real de una dependencia externa durante las pruebas
un SEAM es un punto de inyección doble

El artefacto maven con las siguientes coordenadas: \n\nppss.examen:ejemplo:war:1.0-SNAPSHOT\n\nrepresenta el fichero:
1
$HOME/.m2/repository/ppss/examen/ejemplo/1.0-SNAPSHOT/ejemplo-1.0-SNAPSHOT.war
$HOME/.m2/repository/ppss/examen/ejemplo-1.0-SNAPSHOT.war
$HOME/.m2/repository/ppss/examen/ejemplo/ejemplo-1.0-SNAPSHOT.war
$HOME/.m2/repository/ppss/examen/ejemplo/war/1.0-SNAPSHOT/ejemplo-1.0-SNAPSHOT.war

Si al aplicar el método de caja negra de particiones equivalentes, obtenemos las siguientes particiones de entrada, validas y no validas, teniendo en cuenta la siguiente codificación para identificar las particiones “E” denota entrada,“V” denota valida y “nV” denota no valida. ```Entrada 1 : “E1V1, E1nV1” \nEntrada 2 : “E2V1, E2nV1, E2nV2” ```Indica cual es la cardinalidad del conjunto de casos de prueba eficiente y efectivo al aplicar dicho método:
1
4
5
No se puedo obtener si no se conocen las particiones de salida validas y no válidas.
3

Indica cuá es la complejidad ciclomática del siguiente código:```if (a > b && a < c || c < b) \n\ta = b;\nelse if (a < b || c > a)\n\tc = a;\nelse\n\tb = c;```
1
6
4
3
5

Indica cuál de las siguientes afirmaciones es cierta:
4
los defectos del software que no han sido detectados con las pruebas unitarias, serán detectados con las pruebas de integración
con pruebas de itnegración no se pueden detectar errores en las unidades a intergrar
las pruebas unitarias son dinámicas y las pruebas de integración son estáticas
todas las afirmaciones del resto de opciones son falsas

Indica cuál de las siguientes afirmaciones es cierta:
2
un proyecto maven con un empaquetado "pom" debe incluir la etiqueta <parent> en su pom.xml
un proyecto maven con un empaquetado "pom" no tiene asociada por defecto ninguna goal a la fase test
el mecanismo reactor de maven permite que un proyectos hijo hereden elementos de la configuración del proyecto padre
todas las afimraciones del resto de opciones son falsas

Indica cuál de las siguientes afirmaciones es cierta:
4
la etiqueta <modules> en un aggregator pom permite que los módulos indicados hereden su configuración (propiedades, dependencias, y otros elementos)
todas las afirmaciones del resto de opciones son falsas
el mecanismo reactor de maven permite que los proyectos hijo hereden elementos de la configuración del proyecto padre
para establecer una relación de agregación entre proyectos maven, no es necesario usar la etiqueta <parent>

En un plan de un proyecto software:
1
Las pruebas unitarias, integración, y sistema, no se realizan siempre en ese orden, dependerá del modelo de proceso aplicado y del horizonte de planificación
Las pruebas unitarias, integración, y sistema, no se realizan siempre en ese orden, dependerá de si usamos una planificación adaptativa o predictiva
Las pruebas unitarias, integración, y sistema, se realizan siempre en ese orden
Todas las afirmaciones del resto de opciones son falsas

Con respecto a las pruebas de aceptación:
4
el diseño de las pruebas lo realiza el propio cliente
tienen como objetivo encontrar defectos porque son pruebas dinámicas
el código a probar es el mismo que en las pruebas del sistema
todas las afirmaciones del resto de opciones son falsas
