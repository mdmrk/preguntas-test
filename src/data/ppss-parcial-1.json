[
  {
    "id": 1,
    "question": "Indica cuál de las siguientes afirmaciones es falsa acerca del uso de categorías en jUnit",
    "options": [
      "Se anota como categoría un método anotado como @test",
      "Se anota como categoría varios drivers de una clase",
      "Se anota como categoría una interfaz",
      "Se anota como categoría una clase que contiene drivers"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 2,
    "question": "Dado el siguiente driver para probar metodoSUT():```java\n@Test (expected = MiExcepcion.class)\nPublic void testC1(){\n\tInt resultadoEsperado = 0;\n\tInt resultadoReal = metodoSut();\n\tAssertEquals(resultadoEsperado, resultadoReal);\n}\n```",
    "options": [
      "Error, si el metodoSUT() provoca la excepción MiExecpcion.class",
      "Passed, si el metodoSUT() provoca la excepción MiExecpcion.class",
      "Passed, si el metodoSUT() devuelve 0",
      "Failed, si el metodoSUT() provoca la excepción MiExecpcion.class"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 3,
    "question": "Indica cuál de las siguientes afirmaciones es cierta con respecto a estos 3 tipos de objeto que podemos crear una librería EasyMock: NiceMock, mock y StrictMock",
    "options": [
      "Con los tipos Mock y NiceMock se lanza un AssertionError si no hemos programado las expect.. de algún método",
      "Con los tres tipos se verifica si todas las llamadas esperadas a métodos realizadas por el doble realizan con los argumentos especificados",
      "Con los tres tipos siempre hay que invocar al método replay() de la librería.",
      "Con los tipos Mock y StrictMock se verifica el orden en el que se realizan las invocaciones al doble"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 4,
    "question": "Con respecto al método de caja negra de particiones equivalente, indica cuál de las siguientes afirmaciones es cierta:",
    "options": [
      "Todas las entradas y salidas se corresponden con parámetros de la SUT",
      "Dos elementos de la misma partición de entrada no se pueden corresponder con dos elementos de particiones de salida diferentes",
      "Las particiones pueden compartir elementos para mantener algunos datos de prueba redundantes",
      "Se deben probar todas las posibles combinaciones de las particiones"
    ],
    "correctAnswer": 1,
    "tags": []
  },
  {
    "id": 5,
    "question": "Cualquier librería que sea requerida en el proceso de construcción de un proyecto Maven",
    "options": [
      "si no se encuentra en un repositorio remoto, se busca en el repositorio local",
      "si se encuentra en un repositorio remoto, se descarga en el directorio target",
      "todas las afirmaciones anteriores son falsas",
      "si no se encuentra en un repositorio remoto, se busca en el directorio .m2"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 6,
    "question": "Utilizando un método de caja negra de particiones equivalentes si tenemos una entrada asociada a un tipo enumerado con 3 valores, indica cuál de las siguientes afirmaciones es falsa",
    "options": [
      "Podemos tener dos particiones válidas de dicha entrada",
      "Podemos tener una sola partición válida de dicha entrada",
      "Podemos tener tres particiones válidas de dicha entrada",
      "Podemos tener tres particiones no válidas de dicha entrada"
    ],
    "correctAnswer": 3,
    "tags": []
  },
  {
    "id": 7,
    "question": "Si al aplicar el método de caja negra de particiones equivalentes obtendremos las siguientes particiones de entrada, válidas y no válidas, teniendo en cuenta la siguiente codificación para identificar las particiones \"E\" denota entrada,\"V\" denota válida y \"nV\" denota no válida.```\nEntrada 1 : \"E1V1, E1V2, E1nV1\"\nEntrada 2 : \"E2V1, E2nV1, E2nV2\"\n```\nIndica cuál es la cardinalidad del conjunto de casos de prueba eficiente y efectivo al aplicar dicho método:",
    "options": [
      "4",
      "5",
      "No se puede obtener si no se conocen las particiones de salida válidas y no válidas.",
      "6"
    ],
    "correctAnswer": 1,
    "tags": []
  },
  {
    "id": 8,
    "question": "En un método de diseño de pruebas basado en el flujo de control del código, un camino imposible detectado",
    "options": [
      "No se asocia a ningún caso de prueba",
      "Se asocia a un caso de prueba con un resultado esperado desconocido",
      "Se asocia a un caso de prueba con valores de entrada desconocidos",
      "Todas las afirmaciones del resto de opciones son falsas"
    ],
    "correctAnswer": 0,
    "tags": []
  },
  {
    "id": 9,
    "question": "Cuando refactorizamos la SUT para poder inyectar el doble:",
    "options": [
      "Añadimos un método setter estamos obligando a cualquier código cliente de la SUT a conocer dicha dependencia antes de invocarla",
      "Si añadimos un parámetro a la SUT estamos obligados a declarar la dependencia como un atributo de la clase que contiene la SUT",
      "Si añadimos una factoría local, alteramos el comportamiento de la clase que contiene la SUT",
      "Si añadimos una clase factoría no se altera el código de producción"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 10,
    "question": "Indica las líneas en las que identificamos las dependencias externas de la SUT calculaConsumo():```java\n## paquete ppsss.ejercicio2\npublic class GestorLLamadas {\n\tprivate static final double TARIFA_NOCTURNA=10.5;\n\tprivate static final double TARIFA_DIURNA=20.8;\n\t\n\tpublic Calendario getCalendario(){\n\t\tCalendario c = new Calendario();\n\t\treturn c;\n\t}\n\t\n\tpublic double calculaConsumo( int minutos){\n\t\tCalendario c = getCalendario();\n\t\tint hora = c.getHoraActual();\n\t\tif(hora < 8 || hora > 20){\n\t\t\treturn minutos * TARIFA_NOCTURNA;\n\t\t}else{\n\t\t\treturn minutos * TARIFA_DIURNA;\n\t\t}\n\t}\n}\n```",
    "options": [
      "En las líneas 7, 12, y 13",
      "Solo en la línea 13",
      "En las líneas 7 y 12",
      "En las líneas 12 y 13"
    ],
    "correctAnswer": 3,
    "tags": []
  },
  {
    "id": 11,
    "question": "El comando mvn de Maven",
    "options": [
      "Sirve para ejecutar fases, pero no goals",
      "Sirve para ejecutar goals pero no fases",
      "Se ejecuta desde el directorio donde se encuentra el fichero de configuración del proyecto Maven",
      "Se ejecuta desde el directorio src para compilar los ficheros fuentes y desde el directorio test para compilar los ficheros con las pruebas"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 12,
    "question": "Dado el siguiente diagrama de Venn que hemos trabajado en clase:![Diagrama](/data/images/ppss-p1-1.png){width=200 height=200}\nIndica cuál de las siguientes afirmaciones es cierta:",
    "options": [
      "Un tester debe intentar que el subconjunto 7 sea lo más grande posible",
      "Con métodos de caja negra y de caja blanca, se pueden alcanzar comportamientos de los subconjuntos 1 y 2",
      "Con un método de caja negra se pueden alcanzar comportamientos del subconjunto 3",
      "Con un método de caja blanca se pueden alcanzar comportamientos del subconjunto 4"
    ],
    "correctAnswer": 1,
    "tags": []
  },
  {
    "id": 13,
    "question": "Si en el pom.xml de nuestro proyecto añadimos la siguiente propiedad:```xml\n<properties>\n\t<miPropiedad>misTests</miPropiedad>\n</properties>\n```\ny la siguiente configuración del plugin maven-surefire-plugin:\n```xml\n<configuration>\n\t<groups>${miPropiedad}</groups>\n</configuration>\n```\ny tiene la siguiente clase para los tests con 3 drivers:\n```java\nclass MiClaseTest {\n\t@Tag(\"misTests\")\n\t@Test void test1() {\n\t\t## aquí vendría el código del test\n\t}\n\t\n\t@Tag(\"otroTest\")\n\t@Test void test2() {\n\t\t## aquí vendría el código del test\n\t}\n\t\n\t@Test void test3() {\n\t\t## aquí vendría el código del test\n\t}\n}\n```\nSi desde la línea de comandos ejecutamos la orden:\n`mvn test -Dgroups=\"\"`",
    "options": [
      "Se ejecutan los 3 drivers",
      "No se ejecuta ningún driver porque en la orden no se indica ninguna etiqueta",
      "Se ejecuta solo test3()",
      "Se ejecuta solo test1()"
    ],
    "correctAnswer": 0,
    "tags": []
  },
  {
    "id": 14,
    "question": "Con cuál de los siguientes comandos de Maven no se ejecutarían las pruebas unitarias:",
    "options": [
      "Mvn clean compile surefire:test",
      "Mvn test",
      "Mvn clean test-compile surefire:test",
      "Mvn test-compile surefire:test"
    ],
    "correctAnswer": 0,
    "tags": []
  },
  {
    "id": 15,
    "question": "Indica cuál de las siguientes afirmaciones es falsa:",
    "options": [
      "Durante el proceso de desarrollo de un producto, cuanto antes se detecte un defecto menos costoso será repararlo",
      "Aunque un producto funcione de acuerdo con los requerimientos especificados puede que no satisfaga las expectativas del cliente",
      "Aunque probemos un código utilizando un conjunto de pruebas eficiente y efectivo y todos los test pasen, no podemos garantizar que el código no presenta ningún defecto",
      "Las pruebas pueden demostrar la ausencia de defectos"
    ],
    "correctAnswer": 3,
    "tags": []
  },
  {
    "id": 16,
    "question": "El método de diseño de transición de estados",
    "options": [
      "Requiere que hayamos implementado todas las unidades para poder aplicarlo",
      "Al igual que el método del camino básico se aplica en pruebas dinámicas",
      "Es un método funcional y por lo tanto lo podemos aplicar en cualquier nivel de pruebas",
      "Representa las transiciones a partir de entradas y acciones"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 17,
    "question": "Indica cuál de las siguientes afirmaciones es falsa con respecto al uso de un objeto de tipo IMocksControl:",
    "options": [
      "no permite el uso de partial mock",
      "permite chequear el orden de invocaciones entre varios dobles",
      "no permite el uso de verify()",
      "permite chequear el orden de las invocaciones de un doble"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 18,
    "question": "Al ejecutar una clase de test que contiene n drivers:",
    "options": [
      "el método anotado con @BeforeEach se ejecuta n-1 veces",
      "el método anotado con @AfterAll se ejecuta n veces",
      "el método anotado con @BeforeAll se ejecuta una vez",
      "el método anotado con @AfterEach se ejecuta n-1 veces"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 19,
    "question": "Con el método del camino básico de McCabe:",
    "options": [
      "debemos elegir el conjunto mínimo de caminos para conseguir que todas las sentencias se ejecuten al menos una vez en cada caso de prueba",
      "todas las afirmaciones del resto de opciones son falsas",
      "debemos elegir el conjunto mínimo de caminos para conseguir ejecutar todas las condiciones al menos una vez en cada caso de prueba",
      "debemos elegir todos los caminos del grafo"
    ],
    "correctAnswer": 1,
    "tags": []
  },
  {
    "id": 20,
    "question": "Para realizar pruebas de una SUT que contiene dependencias externas,",
    "options": [
      "usaremos una verificación basada en el estado para pruebas unitarias, y una verificación basada en el comportamiento para pruebas de integración",
      "todas las afirmaciones del resto de opciones son falsas",
      "el primer paso es identificar los seams que contiene la SUT",
      "no está permitido modificar la SUT de ninguna forma para realizar pruebas unitarias"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 21,
    "question": "![Diagrama](/data/images/ppss-p1-2.png){width=200 height=200}",
    "options": [
      "En las líneas 14 y 18",
      "Dejo la pregunta en blanco",
      "En las líneas 10 y 14",
      "En las líneas 11 y 18"
    ],
    "correctAnswer": 3,
    "tags": []
  },
  {
    "id": 22,
    "question": "Dado el siguiente método, que devuelve el sumatorio desde 1 hasta un determinado valor n:```java\nint sumatorio(int n) {\n\tint suma = 0;\n\tfor (int i=1; i<= n; i++){\n\t\tsuma +=i;\n\t}\n\treturn suma;\n}\n```\nSe puede aplicar el método del camino básico",
    "options": [
      "con uno o 2 caminos",
      "al contener un bucle cuyo número de iteraciones depende del valor de entrada n, no podemos saber el número de caminos",
      "con n caminos",
      "con más de 2 caminos"
    ],
    "correctAnswer": 0,
    "tags": []
  },
  {
    "id": 23,
    "question": "Indica cuál de las siguientes afirmaciones es cierta:",
    "options": [
      "si es necesario, se puede alterar temporalmente el código de la SUT para realizar pruebas",
      "si es necesario, refactorizamos la SUT para eliminar sus dependencias externas",
      "un doble reemplaza al código real de una dependencia externa durante las pruebas",
      "un SEAM es un punto de inyección doble"
    ],
    "correctAnswer": 2,
    "tags": []
  },
  {
    "id": 24,
    "question": "Si al aplicar el método de caja negra de particiones equivalentes, obtenemos las siguientes particiones de entrada, válidas y no válidas, teniendo en cuenta la siguiente codificación para identificar las particiones \"E\" denota entrada,\"V\" denota válida y \"nV\" denota no válida.```\nEntrada 1 : \"E1V1, E1nV1\"\nEntrada 2 : \"E2V1, E2nV1, E2nV2\"\n```\nIndica cuál es la cardinalidad del conjunto de casos de prueba eficiente y efectivo al aplicar dicho método:",
    "options": [
      "4",
      "5",
      "No se puede obtener si no se conocen las particiones de salida válidas y no válidas.",
      "3"
    ],
    "correctAnswer": 0,
    "tags": []
  },
  {
    "id": 25,
    "question": "Indica cuál es la complejidad ciclomática del siguiente código:```java\nif (a > b && a < c || c < b)\n\ta = b;\nelse if (a < b || c > a)\n\tc = a;\nelse\n\tb = c;\n```",
    "options": [
      "6",
      "4",
      "3",
      "5"
    ],
    "correctAnswer": 0,
    "tags": []
  },
  {
    "id": 26,
    "question": "Indica cuál de las siguientes afirmaciones es cierta:",
    "options": [
      "los defectos del software que no han sido detectados con las pruebas unitarias, serán detectados con las pruebas de integración",
      "con pruebas de integración no se pueden detectar errores en las unidades a integrar",
      "las pruebas unitarias son dinámicas y las pruebas de integración son estáticas",
      "todas las afirmaciones del resto de opciones son falsas"
    ],
    "correctAnswer": 3,
    "tags": []
  },
  {
    "id": 27,
    "question": "Indica cuál de las siguientes afirmaciones es cierta:",
    "options": [
      "un proyecto maven con un empaquetado \"pom\" debe incluir la etiqueta <parent> en su pom.xml",
      "un proyecto maven con un empaquetado \"pom\" no tiene asociada por defecto ninguna goal a la fase test",
      "el mecanismo reactor de maven permite que un proyectos hijo hereden elementos de la configuración del proyecto padre",
      "todas las afirmaciones del resto de opciones son falsas"
    ],
    "correctAnswer": 1,
    "tags": []
  },
  {
    "id": 28,
    "question": "Indica cuál de las siguientes afirmaciones es cierta:",
    "options": [
      "la etiqueta <modules> en un aggregator pom permite que los módulos indicados hereden su configuración (propiedades, dependencias, y otros elementos)",
      "todas las afirmaciones del resto de opciones son falsas",
      "el mecanismo reactor de maven permite que los proyectos hijo hereden elementos de la configuración del proyecto padre",
      "para establecer una relación de agregación entre proyectos maven, no es necesario usar la etiqueta <parent>"
    ],
    "correctAnswer": 3,
    "tags": []
  },
  {
    "id": 29,
    "question": "En un plan de un proyecto software:",
    "options": [
      "Las pruebas unitarias, integración, y sistema, no se realizan siempre en ese orden, dependerá del modelo de proceso aplicado y del horizonte de planificación",
      "Las pruebas unitarias, integración, y sistema, no se realizan siempre en ese orden, dependerá de si usamos una planificación adaptativa o predictiva",
      "Las pruebas unitarias, integración, y sistema, se realizan siempre en ese orden",
      "Todas las afirmaciones del resto de opciones son falsas"
    ],
    "correctAnswer": 0,
    "tags": []
  },
  {
    "id": 30,
    "question": "Con respecto a las pruebas de aceptación:",
    "options": [
      "el diseño de las pruebas lo realiza el propio cliente",
      "tienen como objetivo encontrar defectos porque son pruebas dinámicas",
      "el código a probar es el mismo que en las pruebas del sistema",
      "todas las afirmaciones del resto de opciones son falsas"
    ],
    "correctAnswer": 3,
    "tags": []
  }
]