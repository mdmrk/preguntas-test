Q: Indica cuál de las siguientes afirmaciones es cierta:
A: 2
todas las afirmaciones del resto de opciones son falsas
en una estrategia de integración top-down los componentes de la lógica de negocio serán los menos probados
en cualquier estrategia de integración las últimas unidades integradas serán las más probadas
en una estrategia de integración bottom-up los componentes de la interfaz de usuario serán los primeros en integrarse

Q: respecto a Webdriver:
A: 2
es una librería que sustituye al navegador durante las pruebas
es una librería usada para pruebas de escenarios
es una API que se puede usar como una alternativa a JMeter
todas las afirmaciones del resto de opciones son falsas

Q: Dado el siguiente fragmento de código en Java:
```java
if (x > 5 & y < 2) {
	x = x + 1;
}
if (y > 0) {
	x = x + 2;
}
else {
	x = x + 3;
}
```
y dados los datos de entrada para los siguientes casos de prueba:

Caso 1: x = 4, y = 2
Caso 2: x = 6, y = -1

y teniendo en cuenta los niveles 1 y 3 de cobertura, indica cuál o cuáles de estos niveles se cumplen:
A: 2
sólo el nivel 3
niveles 1 y 3
ninguno de estos niveles
sólo el nivel 1

Q: A partir de este informe de JMeter obtenido con la siguiente configuración del elemento Thread Group:
Number of Threads (users): 1
Loop Count: 1
Indica en qué instante (expresado en segundos) termina su ejecución el usuario:
![Tabla](/data/images/ppss-p2-1.png){width=1564 height=279}
A: 3
3
2
6
no se puede saber porque falta en la configuración el valor Ramp-up

Q: En un plan de pruebas:
A: 4
El diseño de las pruebas siempre es anterior a su implementación, excepto en BDD
El diseño de las pruebas no condiciona la calidad de las pruebas si conseguimos niveles altos de cobertura
Podemos omitir alguno de los niveles de pruebas y cambiar su orden si fuese necesario
Podemos separar los procesos de diseño e implementación, pero no su orden

Q: Indica cuál es el valor para del contador de líneas a nivel de clase, según el siguiente informe de JaCoCo:
![Tabla](/data/images/ppss-p2-2.png){width=1616 height=165}
A: 1
0,70
0,30
0,75
ninguno de los valores indicados en el resto de opciones

Q: Indica cuál de las siguientes afirmaciones es falsa:
A: 3
durante el proceso de desarrollo de un producto, cuanto antes se detecte un defecto menos costoso será repararlo
aunque probemos un código utilizando un conjunto de pruebas eficiente y efectivo y todos los tests pasen, no podemos garantizar que el código no presenta ningún defecto
las pruebas pueden demostrar la ausencia de defectos
aunque un producto funcione de acuerdo a los requerimientos especificados puede que no satisfaga las expectativas del cliente

Q: Dado el siguiente plan JMeter que es ejecutado por un sólo usuario con las siguientes configuraciones:
Thread Properties
	Loop Count: 3

En ambos Loop Controller
	Loop Count: 2
![Lista](/data/images/ppss-p2-3.png){width=400 height=400}
A: 4
1
3
5
7

Q: En un plan de un proyecto software:
A: 4
Las pruebas unitarias, integración, y sistema, no se realizan siempre en ese orden, dependerá de si usamos una planificación adaptativa o predictiva
Las pruebas unitarias, integración, y sistema, no siempre se realizan en ese orden, dependerá del modelo de proceso aplicado y del horizonte de planificación
Todas las afirmaciones del resto de opciones son falsas
Las pruebas unitarias, integración, y sistema, se realizan siempre en ese orden

Q: Indica cuál de las siguientes afirmaciones es cierta:
A: 3
las pruebas unitarias son dinámicas y las pruebas de integración son estáticas
con pruebas de integración no se pueden detectar errores en las unidades a integrar
todas las afirmaciones del resto de opciones son falsas
los defectos del software que no han sido detectados con las pruebas unitarias, serán detectados con las pruebas de integración

Q: Indica cuál de las siguientes afirmaciones es cierta:
A: 2
un proyecto maven con un empaquetado "pom" debe incluir la etiqueta `<parent>` en su pom.xml
un proyecto maven con un empaquetado "pom" no tiene asociada por defecto ninguna goal a la fase test
el mecanismo reactor de maven permite que un proyectos hijo hereden elementos de la configuración del proyecto padre
todas las afirmaciones del resto de opciones son falsas

Q: Indica cuál de las siguientes afirmaciones es cierta:
A: 3
los objetos de tipo WebElement se instancian con el constructor de una Page Object cuando se usa la clase PageFactory
si no usamos la clase PageFactory, hay que localizar los elementos de las páginas con la anotación @FindBy
todas las afirmaciones del resto de opciones son falsas
cuando utilizamos la clase PageFactory, los elementos de las páginas se localizan con el método `findElement()`

Q: Un test que use Webdriver con maven:
A: 4
puede implementarse en src/main
todas las afirmaciones del resto de opciones son falsas
necesariamente se debe ejecutar durante la fase verify
puede ejecutarse durante la fase test

Q: Teniendo en cuenta el proyecto matriculación usado en prácticas:
![grafo](/data/images/ppss-p2-4.png){width=400 height=200}
A: 3
Podemos integrar DAO + PROXY usando alguna estrategia de integración
No podemos hacer pruebas unitarias sobre el módulo DAO ya que necesitamos acceder a una BD
Podemos integrar DAO + PROXY usando una estrategia de integración
Sobre BO podemos realizar tanto pruebas unitarias como de integración

Q: ¿Cuál de las siguientes afirmaciones es falsa sobre las ventajas de la integración continua (CI):
A: 3
Normalmente, los errores serán más fáciles de resolver
El proceso de encontrar errores es menos costoso
Permite que los programadores no tengan que ejecutar las pruebas unitarias en su equipo
Requiere automatizar el proceso de construcción

Q: Indica cuál de las siguientes afirmaciones es cierta:
A: 1
Un test DBUnit no necesariamente usa la clase Assertion, puede usar la clase Assertions de JUnit
Las anotaciones DBUnit son necesarias para ejecutar los tests de integración
El plugin sql lo hemos usado para inicializar el estado de la BD en cada uno de los tests
La cadena de conexión con la BD se usa solamente en las tests y en el pom

Q: A partir de este informe de JMeter obtenido con la siguiente configuración del elemento Thread Group:
Number of Threads (users): 1
Loop Count: 2
Indica en qué instante (expresado en segundos) termina su ejecución el usuario:
![Tabla](/data/images/ppss-p2-5.png){width=1564 height=279}
A: 2
2,2
1,1
3,3
no se puede saber porque falta en la configuración el valor Ramp-up

Q: Dado el siguiente fragmento de código en Java:
```java
if (x > 5 & y < 2) {
	x = x + 1;
}
if (y > 0) {
	x = x + 2;
}
else {
	x = x + 3;
}
```
y dados los datos de entrada para los siguientes casos de prueba:

Caso 1: x = 4, y = -1
Caso 2: x = 6, y = 2

y teniendo en cuenta los niveles 1 y 3 de cobertura, indica cuál o cuáles de estos niveles se cumplen:
A: 1
sólo el nivel 3
niveles 1 y 3
ninguno de estos niveles
sólo el nivel 1

Q: Indica cuál de las siguientes afirmaciones es cierta:
A: 4
todas las afirmaciones del resto de opciones son falsas
cuando utilizamos la clase PageFactory, el método `initElements()` tenemos que invocarlo desde el constructor de la page object asociada a la página principal
es conveniente que los objetos de tipo Alert sean manejados en el código de los tests
cuando utilizamos la clase PageFactory, no creamos una page object usando `new()`

Q: En un test (plan) JMeter:
A: 3
No es necesario usar un servidor proxy si nuestros tests solo usan peticiones http POST
Si usamos un servidor proxy tendremos que cambiar la configuración del navegador para ejecutar el plan
todas las afirmaciones del resto de opciones son falsas
Si usamos un servidor proxy podremos ejecutar las pruebas aunque el servidor real no esté en ejecución

Q: Con respecto a las pruebas de aceptación:
A: 3
el diseño de las pruebas lo realiza el propio cliente
tienen como objetivo encontrar defectos porque son pruebas dinámicas
el código a probar es el mismo que en las pruebas del sistema
todas las afirmaciones del resto de opciones son falsas

Q: Indica cuál es el valor para el contador de complejidad ciclomática a nivel de clase, según el siguiente informe de JaCoCo:
![Tabla](/data/images/ppss-p2-6.png){width=1616 height=165}
A: 2
ninguno de los valores indicados en el resto de opciones
0,80
0,20
0,30

Q: Indica cuál de las siguientes afirmaciones es cierta:
A: 4
La etiqueta `<modules>` en un aggregator pom permite que los módulos indicados hereden su configuración (propiedades, dependencias y otros elementos)
Todas las afirmaciones son falsas
El mecanismo reactor de Maven permite que los proyectos hijos hereden elementos de la configuración del proyecto padre
Para establecer una relación de agregación entre proyectos Maven, no es necesario usar la etiqueta `<parent>`

Q: A partir de este informe de JMeter obtenido con la siguiente configuración del elemento Thread Group:
Number of Threads (users): 1
Loop Count: 3
Indica en qué instante (expresado en segundos) termina su ejecución el usuario:
![Tabla](/data/images/ppss-p2-7.png){width=1564 height=279}
A: 2
2,2
1,1
3,3
no se puede saber porque falta en la configuración el valor Ramp-up